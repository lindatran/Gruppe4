def flush(hand):

Må trekke ut kun suits, altså tegn (ikke tall)
Se om alle suits er av lik type (D diamond, C club, H heart, S space)
ulike bokstaver for hver
For hver rank og suit in hånd:
ta hånd og sjekk om alle er like
Hvis alle du finner er like, så har du flush.
kan bruke set funksjon
hvis utfallet er lik 5 så er alle like.
obs: må ha noe å sammenlikne med.
4 lister som har lik suit i alle 5 kortene.



def straight(ranks)

ranks = [14, 13, 12, 11, 10]

def sammenlikn(hand):
    a = range(hand[0], (hand[0] - 5), -1)

    if a == hand:
        return True
    else:
        return False
    
print sammenlikn(ranks)


def kind(n, ranks)

Hvor mange ganger finner man samme verdi gjenntatt i listen (hånd)?
fk [9, 9, 9, 9, 7]
n altså, må altså legge selv inn hvor mange kort den skal ha like av, feks 4
hvor mange er det av tallet 9? 4.
den må vise kun 3 like hvis du vil ha 3 like, og ikke 2 like
Hvis den har 4 like må den returnere det tallet den har fire like av.
count funksjon for å finne ut hvor mange ganger x er i listen
if setning, hvis hånden har tallet 9 fire ganger i listen så returner tallet 9
else, hvis ikke returner null

a = [1,1,1,1,2,2,2,2,3,3,4,5,5]
from itertools import groupby
[len(list(group)) for key, group in groupby(a)]

Output:
[4, 4, 2, 1, 2]

hånd = [2, 2, 2, 1, 1]

output:
[3, 2]








ranks = [1, 1, 2, 2, 2]

def kind(n, ranks):
    for card in ranks:
        a = ranks.count(card)
        if a == n:
            return card

print kind(3, ranks)


her er løsning på python-tutor




def two_pair:

[8, 6, 6, 5, 5]

Kort som er like med to forskjellige verdier
Lese ranken for å finne ut hvilket par som er størst.
De høyeste verdiene til venstre
Kan du bruke kind funksjonen?
n = 2
første gang vil vi få det største paret
den vil finne par i 6 først
returnerer 6
(Finner to kort som er like)x2
utelate det kortet som allerede har blitt brukt
for eksempel kortet 6 først
neste gang metoden kjøres ignoreres den verdien.
Sjekk verdi på hvert kort, hvis verdi repeteres, send inn godkjenning. Gjenta prosessen, men lag exception for originalverdi.
Hvis du trekker ut alle kortene etter hverandre (for løkke)
etter du har kjørt kind funksjonen en gang.
da kan du vite hvilket kort du ikke skal se etter

(ikke fungerende kode)
def two_pair(ranks):
    forstePar = kind(2, ranks)
    andrePar = kind(2, ranks)
    tupleHand = (forstePar, andrePar)
    return tupleHand

card_rank():

rankMapping = (("2", 2),
               ("3", 3),
               ("4", 4),
               ("5", 5),
               ("6", 6),
               ("7", 7),
               ("8", 8),
               ("9", 9),
               ("T", 10),
               ("J", 11),
               ("Q", 12),
               ("K", 13),
               ("A", 14))
               
cards = ['AS', '4S', '5C', '2D']

def card_rank(cards):
    cardList = []
    ranks = [r for r,s in cards]
    ranks.sort(reverse=True)
    for suit, number in rankMapping:
        for card in ranks:
            #   Hvordan sjekke verdien til en string (lavere enn 10)?
            if card == suit:
                cardList.append(number)
    cardList.sort(reverse=True)
    return cardList
                
                
print card_rank(cards)

problemet med koden er at den kun printer ut de tallene som enten er 10 eller mer.
Dette ble fikset med å utvide rankMapping til å inkludere alle kortene fra 2 til ess.


def deal():

n = 5 # fem kort
deck = liste over hele kortstokken. 2-A, SHDC
numhands = hvor mange spillere

random.shuffle brukes for å stokke kort i en tilfeldig rekkefølge

Deretter del ut kort avhengig hvor mange spillere det er satt inn

#  hvert kort skal inneholde r+s. Hvor man henter r i “23456789TJQKA” og s i “SHDC” 
mydeck =[r+s for r in “23456789TJQKA” for s in “SHDC”]

deal(numhands, n=5, deck=mydeck)

random.shuffle(deck)

return # returner deler av listen deck avhengig av hvor mange numhands som er angitt


def poker(hands):

# returner den hånden som har høyest rank
# Kjører hand_rank på hver hand og returner den høyeste

return max(hands, key=hand_rank)


def hand_rank():

# Sjekke en hånd for hvilken rank den har
# Begynner fra toppen og sjekker først om den finner straight flush.
# Deretter 4 like, fullt hus, straight, flush, 3 like, 2 par, 1 par, høyest kort

If Straight + flush (8):
straight:
sjekk om høyeste kort minus laveste kort er 4
sjekk om det er fem ulike kortverdier

flush: sjekk om alle kortene har samme symbol (if len(symbol)=1, woohoo)

if highcard = 14 and symbol = S
return royal straight flush

elif 4 like:
sjekk om en hånd har 4 like verdier i en hånd

elif fullt hus: elif 3 like + 2 like (som ikke er de samme som 3 like)

elif straight: straight

elif flush: flush

elif 3 like:
sjekk om en hånd har 3 like verdier i en hånd

elif 2 par: 2 like + 2 like

elif 1 par:
sjekk om en hånd har 2 like verdier i en hånd

else: Høyeste kort (rank 0 + tuple av kort-serien)

